## SearchSystem

Класс `SearchSystem` реализует поисковый индекс. Чтобы добавить новый документ в индекс используется метод `AddDocument(id, new_document)`. С помощью метода `FindTopDocuments(raw_reque)` можно получить отсортированный по релевантности массив структур `Document`, содержащих `id` и `relevance` каждого документа на запрос `raw_reque`.

## Доказательство корректности
1. Код корректно индексирует документы, разбивая их на слова и сохраняя их количество в `word_index[word][id]`;
2. При поиске запроса считается релевантность документов, суммируя количество вхождений запрашиваемых слов.
3. Быстрая фильтрация `std::nth_element` оставляет топ-5 релевантных документов, а `std::sort` упорядочивает их по убыванию релевантности и `id`;
Алгоритм полностью соответствует условиям задачи и гарантирует корректный вывод.

## Временная сложность
- Добавление документа AddDocument():
    - SplitIntoWordsNoStop() разбивает строку документа на слова за O(L), где L - количество слов в документе;
    - Запись в word_index — в среднем за O(1) на слово.
    - Итоговая сложность - O(N * L), где N — число документов, L — средняя длина документа.
- Обработка запроса FindTopDocuments() 
    - SplitIntoWordsNoStop() разбивает строку запроса на слова за также за O(L);
    - FindMatchedDocuments() перебирает все слова за О(Q), для каждого слова получаем список документов, в которых оно встречается. В худшем случае слововстречается во всех документах O(N);
    - Сортировка релевантных документов: `std::nth_element` за O(D) находит топ-5 элементов и помещает их в начало, где D - кол-во релевантных документов. `std::sort` сортирует только 5 элементов, поэтому можно считать O(5 log 5) = O(1)
    -  Итогова сложность обработки одного запроса O(Q * N + D);

## Пространственная сложность
- хранение индекса `word_index` - в худшем случае, если каждое слово есть в каждом документе, `word_index` занимает O(W * N) памяти, где W - количество уникальных элементов;
- обработка запроса `query_words` - хранит слова из запроса и их количество О(1);
- хранение релевантностей `relevances` - в худшем случае, все N документов релевантны О(N) памяти;
- хранение топ-документов `top_documents` - хранит маскимум 5 элементов О(1);
Итоговая сложность O(W * N + N) ≈ O(W * N) (если W ≈ L, то O(L * N)).
Потребление памяти может быть очень большим, если в каждом документе много уникальных слов.

## Пример использования
Ввод:
```MARKDOWN
3
i love coffee
coffee with milk and sugar
free tea for everyone
3
i like black coffee without milk
everyone loves new year
mary likes black coffee without milk

```
Вывод:
```MARKDOWN
1 2
3
2 1
```
